# -*- coding: utf-8 -*-
"""
PROT√ìTIPO: VETORES ANTECEDENTES DA DIFUS√ÉO PARA TECNOLOGIAS EMERGENTES
APLICATIVO WEB INTERATIVO
Autor da Metodologia: Fabrizio Bruzetti (TA - FGV)
Desenvolvimento da Automa√ß√£o: Gemini (Google)
Data: 23 de Junho de 2025
VERS√ÉO: 21.0 (Ajuste final na estrutura de apresenta√ß√£o dos gr√°ficos)
"""

# ==============================================================================
# 1. SETUP INICIAL E IMPORTA√á√ïES
# ==============================================================================
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.stats import t as t_student
from statsmodels.tsa.stattools import ccf
from statsmodels.nonparametric.smoothers_lowess import lowess
import networkx as nx
from datetime import date
import warnings

warnings.filterwarnings("ignore")

# ==============================================================================
# 2. CONFIGURA√á√ÉO DA P√ÅGINA E SIDEBAR
# ==============================================================================
st.set_page_config(
    page_title="Vetores Antecedentes da Difus√£o",
    page_icon="üìà",
    layout="wide"
)

# --- Constru√ß√£o da Barra Lateral (Sidebar) ---
st.sidebar.title("Sobre o Projeto")
st.sidebar.markdown("""
O Projeto visa disponibilizar para a comunidade cient√≠fica e interessados, 
dados e an√°lises referentes √†s Curvas Antecedentes da Difus√£o para tecnologias emergentes.
""")
st.sidebar.divider()

st.sidebar.info(
    "Este site √© parte da continuidade da pesquisa e Trabalho Aplicado para obten√ß√£o do T√≠tulo de "
    "Mestre em Gest√£o para a Competitividade na Linha de Inova√ß√£o Corporativa na FGV/EAESP - "
    "Escola de Administra√ß√£o de Empresas de S√£o Paulo da Funda√ß√£o Get√∫lio Vargas."
)
st.sidebar.divider()

st.sidebar.header("Vis√£o de Futuro")
st.sidebar.markdown(
    "O objetivo desta plataforma √© enriquecer o conte√∫do ao longo do tempo, "
    "seguindo o mesmo protocolo de an√°lise para outras tecnologias emergentes e "
    "se tornando uma refer√™ncia no campo."
)
st.sidebar.divider()

st.sidebar.header("Autor e Contato")
st.sidebar.markdown("""
- **Fabrizio Bruzetti**
- [LinkedIn](https://www.linkedin.com/in/fabriziobruzetti/)
- ‚úâÔ∏è fabrizio@bruzetti.com
""")

# ==============================================================================
# 3. BLOCO DE CONFIGURA√á√ÉO DA AN√ÅLISE
# ==============================================================================
NOME_TECNOLOGIA = "Computa√ß√£o Qu√¢ntica"
ARQUIVO_TRENDS = 'Trends_12Jun.csv'
ARQUIVO_PATENTES = 'Patents_csv_puro_12_Jun.csv'
ARQUIVO_CIENCIA = 'Producao_Cientifica_series_temporal_12_Jun.csv'
ANO_FINAL = 2024
FRAC_LOESS_PADRAO = 0.06

# ==============================================================================
# 4. DEFINI√á√ÉO DAS FUN√á√ïES DE AN√ÅLISE (CACHEADAS PARA PERFORMANCE)
# ==============================================================================
@st.cache_data
def carregar_e_preparar_dados(arq_trends, arq_patentes, arq_ciencia, ano_final):
    df_trends = pd.read_csv(arq_trends, skiprows=2)
    df_patents = pd.read_csv(arq_patentes, delimiter=';', skiprows=1)
    df_science = pd.read_csv(arq_ciencia)
    
    df_trends.columns = ['Semana', 'Interesse']
    df_trends['Semana'] = pd.to_datetime(df_trends['Semana'])
    df_trends['Ano'] = df_trends['Semana'].dt.year
    serie_interesse_anual = df_trends.groupby('Ano')['Interesse'].mean().reset_index()
    serie_interesse_anual = serie_interesse_anual[serie_interesse_anual['Ano'] <= ano_final]

    df_patents.columns = df_patents.columns.str.strip()
    COLUNA_DATA_PATENTE = 'grant date'
    df_patents[COLUNA_DATA_PATENTE] = pd.to_datetime(df_patents[COLUNA_DATA_PATENTE], errors='coerce')
    df_patents.dropna(subset=[COLUNA_DATA_PATENTE], inplace=True)
    df_patents['Ano'] = df_patents[COLUNA_DATA_PATENTE].dt.year
    serie_patentes_anual = df_patents.groupby('Ano').size().reset_index(name='Patentes')
    serie_patentes_anual = serie_patentes_anual[serie_patentes_anual['Ano'] <= ano_final]

    df_science.columns = ['Ano', 'Artigos']
    serie_ciencia_anual = df_science[df_science['Ano'] <= ano_final]

    df_final = pd.merge(serie_interesse_anual, serie_patentes_anual, on='Ano')
    df_final = pd.merge(df_final, serie_ciencia_anual, on='Ano')

    for col in ['Interesse', 'Patentes', 'Artigos']:
        min_val, max_val = df_final[col].min(), df_final[col].max()
        df_final[f'{col}_norm'] = (df_final[col] - min_val) / (max_val - min_val)
        df_final[f'{col}_cum'] = df_final[col].cumsum()
        df_final[f'Cresc_{col}'] = df_final[col].pct_change() * 100
        
    return df_final, df_trends

def plotar_ajuste_geral(t_fit, y_data, titulo, ano_inicial, modelos_fits):
    fig, ax = plt.subplots(figsize=(16, 7))
    anos = np.arange(ano_inicial, ano_inicial + len(y_data))
    
    ax.scatter(anos, y_data, label='Dados Observados (Cumulativo)', color='black', zorder=5)

    if 'Bass' in modelos_fits and modelos_fits['Bass']['params'] is not None:
        y_bass_fit = bass_model(t_fit, *modelos_fits['Bass']['params'])
        ax.plot(anos, y_bass_fit, color='red', linestyle=':', label='Modelo Bass (Ajuste Inadequado)', zorder=3, alpha=0.7)

    if 'Gompertz' in modelos_fits and modelos_fits['Gompertz']['params'] is not None:
        params_g, cov_g = modelos_fits['Gompertz']['params'], modelos_fits['Gompertz']['cov']
        y_pred_g = gompertz_model(t_fit, *params_g)
        alpha=0.05; n=len(y_data); p=len(params_g); dof=max(0,n-p); t_val=t_student.ppf(1.0-alpha/2.0,dof)
        y_err_g = [];
        for i in range(n):
            grad=[];
            for j in range(p): delta=np.zeros(p);delta[j]=1e-6;grad.append((gompertz_model(t_fit[i],*(params_g+delta))-y_pred_g[i])/1e-6)
            var_pred=np.array(grad).T@cov_g@np.array(grad);y_err_g.append(t_val*np.sqrt(var_pred))
        ax.plot(anos, y_pred_g, color='blue', linestyle='--', label='Modelo Gompertz', zorder=4)
        ax.fill_between(anos, y_pred_g - y_err_g, y_pred_g + y_err_g, color='blue', alpha=0.2, label='IC 95% Gompertz')

    if 'Log√≠stico' in modelos_fits and modelos_fits['Log√≠stico']['params'] is not None:
        params_l, cov_l = modelos_fits['Log√≠stico']['params'], modelos_fits['Log√≠stico']['cov']
        y_pred_l = logistic_model(t_fit, *params_l)
        y_err_l = [];
        for i in range(n):
            grad=[];
            for j in range(p): delta=np.zeros(p);delta[j]=1e-6;grad.append((logistic_model(t_fit[i],*(params_l+delta))-y_pred_l[i])/1e-6)
            var_pred=np.array(grad).T@cov_l@np.array(grad);y_err_l.append(t_val*np.sqrt(var_pred))
        ax.plot(anos, y_pred_l, color='green', linestyle='--', label='Modelo Log√≠stico', zorder=4)
        ax.fill_between(anos, y_pred_l - y_err_l, y_pred_l + y_err_l, color='green', alpha=0.2, label='IC 95% Log√≠stico')
    
    ax.set_title(titulo, fontsize=16)
    ax.set_xlabel("Ano", fontsize=12)
    ax.set_ylabel("Valor Cumulativo", fontsize=12)
    ax.legend()
    return fig

def bass_model(t, M, p, q):
    if p + q <= 1e-9 or p <= 1e-9: return np.full_like(t, 1e9)
    a = q / p; b = p + q; exp_bt = np.exp(-b * t); return M * (1 - exp_bt) / (1 + a * exp_bt)
def gompertz_model(t, M, b, c): return M * np.exp(-b * np.exp(-c * t))
def logistic_model(t, M, k, r): return M / (1 + np.exp(-k * (t - r)))
def r_squared(y_true, y_pred):
    residuals = y_true - y_pred; ss_res = np.sum(residuals**2); ss_tot = np.sum((y_true - np.mean(y_true))**2); return 1 - (ss_res / ss_tot) if ss_tot > 0 else 1.0


# ==============================================================================
# 5. CONSTRU√á√ÉO DA INTERFACE PRINCIPAL DO APLICATIVO
# ==============================================================================

st.title(f"An√°lise de Vetores Antecedentes da Difus√£o")
st.header(f"Estudo de Caso: {NOME_TECNOLOGIA}")
st.markdown("Este aplicativo automatiza a an√°lise e visualiza√ß√£o de dados para os vetores antecedentes da difus√£o de tecnologias emergentes.")

if 'analysis_generated' not in st.session_state:
    st.session_state.analysis_generated = False

if st.button('‚ñ∂Ô∏è Gerar An√°lise Completa') or st.session_state.analysis_generated:
    st.session_state.analysis_generated = True

    df_final, df_trends = carregar_e_preparar_dados(ARQUIVO_TRENDS, ARQUIVO_PATENTES, ARQUIVO_CIENCIA, ANO_FINAL)

    with st.expander("Visualizar Tabela de Dados Anuais Consolidados"):
        st.dataframe(df_final)

    st.header("1. An√°lise Individual e Comparada dos Vetores")
    st.markdown("_{An√°lise textual sobre a evolu√ß√£o de cada vetor e a compara√ß√£o entre eles entrar√° aqui...}_")
    
    with st.spinner('Gerando gr√°ficos da an√°lise individual...'):
        tab1, tab2, tab3 = st.tabs(["Interesse P√∫blico", "Inova√ß√£o Formal (Patentes)", "Produ√ß√£o Cient√≠fica"])
        
        sns.set_style("whitegrid")
        plt.rcParams['font.family'] = 'sans-serif'

        with tab1:
            st.subheader("Evolu√ß√£o do Interesse P√∫blico")
            fig, ax = plt.subplots(figsize=(12, 6)); sns.barplot(ax=ax, data=df_final, x='Ano', y='Interesse', color='cornflowerblue'); ax.bar_label(ax.containers[0], fmt='%.1f'); ax.set_title("Evolu√ß√£o do Interesse P√∫blico (Barras Anuais)", fontsize=14); st.pyplot(fig)
            fig, ax = plt.subplots(figsize=(16, 7)); x_ord = df_trends['Semana'].apply(lambda d: d.toordinal()); loess_smoothed = lowess(df_trends['Interesse'], x_ord, frac=FRAC_LOESS_PADRAO); dates_from_ordinal = [date.fromordinal(int(o)) for o in loess_smoothed[:, 0]]; ax.plot(df_trends['Semana'], df_trends['Interesse'], label='Observado (Semanal)', alpha=0.7); ax.plot(dates_from_ordinal, loess_smoothed[:, 1], color='darkred', linestyle='--', label=f'Tend√™ncia Suavizada (frac={FRAC_LOESS_PADRAO})'); ax.legend(); ax.set_title(f"Evolu√ß√£o do Interesse P√∫blico por '{NOME_TECNOLOGIA}'", fontsize=14); st.pyplot(fig)

        with tab2:
            st.subheader("Evolu√ß√£o da Inova√ß√£o Formal")
            fig, ax = plt.subplots(figsize=(12, 6)); sns.barplot(ax=ax, data=df_final, x='Ano', y='Patentes', color='steelblue'); ax.bar_label(ax.containers[0]); ax.set_title("Evolu√ß√£o das Patentes Publicadas", fontsize=14); st.pyplot(fig)
            fig, ax = plt.subplots(figsize=(16, 7)); x_ord_pat = df_final['Ano']; loess_pat = lowess(df_final['Patentes'], x_ord_pat, frac=FRAC_LOESS_PADRAO * 5); ax.plot(df_final['Ano'], df_final['Patentes'], 'o-', label='Observado (Anual)', alpha=0.7, color='steelblue'); ax.plot(loess_pat[:, 0], loess_pat[:, 1], color='darkred', linestyle='--', label=f'Tend√™ncia Suavizada (frac={FRAC_LOESS_PADRAO*5:.2f})'); ax.legend(); ax.set_title("Evolu√ß√£o da Inova√ß√£o Formal com Tend√™ncia Suavizada", fontsize=14); st.pyplot(fig)

        with tab3:
            st.subheader("Evolu√ß√£o da Produ√ß√£o Cient√≠fica")
            fig, ax = plt.subplots(figsize=(12, 6)); sns.barplot(ax=ax, data=df_final, x='Ano', y='Artigos', color='forestgreen'); ax.bar_label(ax.containers[0]); ax.set_title("Evolu√ß√£o dos Artigos Publicados", fontsize=14); st.pyplot(fig)
            fig, ax = plt.subplots(figsize=(16, 7)); x_ord_sci = df_final['Ano']; loess_sci = lowess(df_final['Artigos'], x_ord_sci, frac=FRAC_LOESS_PADRAO * 5); ax.plot(df_final['Ano'], df_final['Artigos'], 'o-', label='Observado (Anual)', alpha=0.7, color='forestgreen'); ax.plot(loess_sci[:, 0], loess_sci[:, 1], color='darkred', linestyle='--', label=f'Tend√™ncia Suavizada (frac={FRAC_LOESS_PADRAO*5:.2f})'); ax.legend(); ax.set_title("Evolu√ß√£o da Produ√ß√£o Cient√≠fica com Tend√™ncia Suavizada", fontsize=14); st.pyplot(fig)
        
        st.subheader("Vis√£o Geral: Compara√ß√£o das Trajet√≥rias Normalizadas")
        fig, ax = plt.subplots(figsize=(16, 8)); ax.plot(df_final['Ano'], df_final['Interesse_norm'], marker='o', label='Interesse P√∫blico'); ax.plot(df_final['Ano'], df_final['Patentes_norm'], marker='o', label='Inova√ß√£o Formal (Patentes)'); ax.plot(df_final['Ano'], df_final['Artigos_norm'], marker='o', label='Produ√ß√£o Cient√≠fica'); ax.legend(); ax.grid(True, which='both', linestyle='--', linewidth=0.5)
        for i, row in df_final.iterrows(): ax.text(row['Ano'], row['Interesse_norm'], f" {row['Interesse_norm']:.2f}", fontsize=9, ha='left'); ax.text(row['Ano'], row['Patentes_norm'], f" {row['Patentes_norm']:.2f}", fontsize=9, ha='left'); ax.text(row['Ano'], row['Artigos_norm'], f" {row['Artigos_norm']:.2f}", fontsize=9, ha='left')
        st.pyplot(fig)

    st.header("2. An√°lise das Taxas de Crescimento")
    st.markdown("_{An√°lise textual sobre as taxas de crescimento entrar√° aqui...}_")
    with st.spinner('Gerando gr√°ficos de crescimento...'):
        fig, axes = plt.subplots(3, 1, figsize=(12, 18), sharex=True)
        ax1 = sns.barplot(ax=axes[0], data=df_final.dropna(), x='Ano', y='Cresc_Interesse', color='cornflowerblue'); ax1.bar_label(ax1.containers[0], fmt='%.1f%%'); axes[0].set_title('Interesse P√∫blico')
        ax2 = sns.barplot(ax=axes[1], data=df_final.dropna(), x='Ano', y='Cresc_Patentes', color='indianred'); ax2.bar_label(ax2.containers[0], fmt='%.1f%%'); axes[1].set_title('Inova√ß√£o Formal (Patentes)')
        ax3 = sns.barplot(ax=axes[2], data=df_final.dropna(), x='Ano', y='Cresc_Artigos', color='olivedrab'); ax3.bar_label(ax3.containers[0], fmt='%.1f%%'); axes[2].set_title('Produ√ß√£o Cient√≠fica')
        plt.tight_layout(rect=[0, 0.03, 1, 0.96]); st.pyplot(fig)

    st.header("3. An√°lise de Correla√ß√£o e Causalidade Inferida")
    st.markdown("_{An√°lise textual sobre correla√ß√µes e o grafo de causalidade entrar√° aqui...}_")
    with st.spinner('Gerando gr√°ficos da an√°lise cruzada...'):
        st.subheader("An√°lise de Correla√ß√£o (CCF) e Heatmap")
        col1, col2 = st.columns(2)
        with col1:
            ccf_matrix = pd.DataFrame(index=['Interesse P√∫blico', 'Inova√ß√£o Formal', 'Produ√ß√£o Cient√≠fica'], columns=['Interesse P√∫blico', 'Inova√ß√£o Formal', 'Produ√ß√£o Cient√≠fica'])
            for v1_col, v1_name in zip(['Interesse_norm', 'Patentes_norm', 'Artigos_norm'], ['Interesse P√∫blico', 'Inova√ß√£o Formal', 'Produ√ß√£o Cient√≠fica']):
                for v2_col, v2_name in zip(['Interesse_norm', 'Patentes_norm', 'Artigos_norm'], ['Interesse P√∫blico', 'Inova√ß√£o Formal', 'Produ√ß√£o Cient√≠fica']):
                    ccf_matrix.loc[v1_name, v2_name] = ccf(df_final[v1_col], df_final[v2_col], adjusted=False)[0]
            ccf_matrix = ccf_matrix.astype(float)
            fig, ax = plt.subplots(figsize=(8, 6)); sns.heatmap(ax=ax, data=ccf_matrix, annot=True, cmap='YlOrRd', fmt=".3f", linewidths=.5, vmin=0.9); ax.set_title("Heatmap das Correla√ß√µes (Lag=0)", fontsize=14); st.pyplot(fig)
        with col2:
            G = nx.DiGraph(); edges = {("Produ√ß√£o Cient√≠fica", "Inova√ß√£o Formal"): ccf_matrix.loc['Produ√ß√£o Cient√≠fica', 'Inova√ß√£o Formal'],("Produ√ß√£o Cient√≠fica", "Interesse P√∫blico"): ccf_matrix.loc['Produ√ß√£o Cient√≠fica', 'Interesse P√∫blico'],("Inova√ß√£o Formal", "Interesse P√∫blico"): ccf_matrix.loc['Inova√ß√£o Formal', 'Interesse P√∫blico'],};
            for (u,v), w in edges.items(): G.add_edge(u,v, weight=w)
            pos = nx.circular_layout(G); edge_labels = {(u,v): f"{d['weight']:.3f}" for u,v,d in G.edges(data=True)}; weights = [d['weight'] * 5 for u,v,d in G.edges(data=True)]
            fig, ax = plt.subplots(figsize=(8, 6)); nx.draw(G, pos, ax=ax, with_labels=True, node_color='skyblue', node_size=2500, font_size=10, font_weight='bold', arrowsize=20, width=weights); nx.draw_networkx_edge_labels(G, pos, ax=ax, edge_labels=edge_labels, font_color='red', font_size=10); ax.set_title("Grafo Direcional das Correla√ß√µes (Lag=0)", fontsize=14); st.pyplot(fig)

    st.header("4. Modelagem de Curvas de Crescimento")
    st.markdown("_{An√°lise textual sobre os resultados da modelagem entrar√° aqui...}_")
    
    with st.spinner('Executando modelagem das curvas...'):
        time_axis = np.arange(len(df_final))
        vetores = {"Interesse P√∫blico": df_final['Interesse_cum'], "Inova√ß√£o Formal": df_final['Patentes_cum'], "Produ√ß√£o Cient√≠fica": df_final['Artigos_cum']}
        resultados_modelagem = {}

        for nome, serie in vetores.items():
            y_data = serie.values; resultados_modelagem[nome] = {}
            modelos_fits = {}
            
            try:
                params_b, cov_b = curve_fit(bass_model, time_axis, y_data, p0=[max(y_data), 0.03, 0.38], maxfev=10000, bounds=([0,0,0], [max(y_data)*5, 1, 5])); r2 = r_squared(y_data, bass_model(time_axis, *params_b)); resultados_modelagem[nome]['Bass'] = {'params': params_b, 'r2': r2}; modelos_fits['Bass'] = {'params': params_b, 'cov': cov_b, 'func': bass_model}
            except Exception: resultados_modelagem[nome]['Bass'] = "Falha"
            try:
                params_g, cov_g = curve_fit(gompertz_model, time_axis, y_data, p0=[max(y_data), 4, 0.1], maxfev=10000); r2 = r_squared(y_data, gompertz_model(time_axis, *params_g)); resultados_modelagem[nome]['Gompertz'] = {'params': params_g, 'r2': r2}; modelos_fits['Gompertz'] = {'params': params_g, 'cov': cov_g, 'func': gompertz_model}
            except Exception: resultados_modelagem[nome]['Gompertz'] = "Falha"
            try:
                params_l, cov_l = curve_fit(logistic_model, time_axis, y_data, p0=[max(y_data), 0.3, np.median(time_axis)], maxfev=10000); r2 = r_squared(y_data, logistic_model(time_axis, *params_l)); resultados_modelagem[nome]['Log√≠stico'] = {'params': params_l, 'r2': r2}; modelos_fits['Log√≠stico'] = {'params': params_l, 'cov': cov_l, 'func': logistic_model}
            except Exception: resultados_modelagem[nome]['Log√≠stico'] = "Falha"
            
            st.subheader(f"Ajustes de Modelo para: {nome}")
            fig = plotar_ajuste_geral(time_axis, y_data, f"Comparativo de Modelos - {nome}", df_final['Ano'].min(), modelos_fits)
            st.pyplot(fig)

    st.header("5. S√≠ntese dos Resultados")
    st.markdown("_{An√°lise textual sobre a tabela de s√≠ntese entrar√° aqui...}_")

    with st.spinner('Gerando tabela de s√≠ntese...'):
        sintese = pd.DataFrame(index=['Interesse P√∫blico', 'Inova√ß√£o Formal', 'Produ√ß√£o Cient√≠fica'])
        sintese['Crescimento M√©dio Anual (%)'] = [df_final['Cresc_Interesse'].mean(), df_final['Cresc_Patentes'].mean(), df_final['Cresc_Artigos'].mean()]
        sintese['CCF max (vs. Produ√ß√£o Cient√≠fica)'] = [ccf_matrix.loc['Interesse P√∫blico', 'Produ√ß√£o Cient√≠fica'], ccf_matrix.loc['Inova√ß√£o Formal', 'Produ√ß√£o Cient√≠fica'], 1.0]

        for n in vetores.keys():
            for m in ['Bass', 'Gompertz', 'Log√≠stico']:
                res = resultados_modelagem[n].get(m, "Falha")
                if isinstance(res, dict): sintese.loc[n, f'Par√¢metros {m}'] = str(np.round(res['params'], 2)); sintese.loc[n, f'R¬≤ {m}'] = res['r2']
                else: sintese.loc[n, f'Par√¢metros {m}'] = res; sintese.loc[n, f'R¬≤ {m}'] = 0.0
        
        st.dataframe(sintese.round(4))
    
    st.balloons()
    st.success('An√°lise completa gerada com sucesso!')